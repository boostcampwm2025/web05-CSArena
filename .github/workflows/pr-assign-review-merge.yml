name: Auto Assign, Review, and Merge

on:
    pull_request:
        types:
            - opened
            - reopened
    pull_request_review:
        types:
            - submitted

jobs:
    auto-assign:
        if: github.event_name == 'pull_request'
        runs-on: ubuntu-latest
        permissions:
            pull-requests: write
            issues: write
        steps:
            - name: Assign PR creator as Assignee
              uses: actions/github-script@v6
              with:
                  script: |
                      const prNumber = context.payload.pull_request.number;
                      const prAuthor = context.payload.pull_request.user.login;
                      const currentAssignees = context.payload.pull_request.assignees.map(a => a.login);
                      if (!currentAssignees.includes(prAuthor)) {
                          await github.rest.issues.addAssignees({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: prNumber,
                            assignees: [prAuthor]
                          });
                          console.log(`Assigned: ${prAuthor}`);
                      } else {
                          console.log(`Already assigned: ${prAuthor}`);
                      }

    auto-reviewers:
        if: github.event_name == 'pull_request'
        runs-on: ubuntu-latest
        needs: auto-assign
        permissions:
            pull-requests: write
        steps:
            - name: Add random reviewers
              uses: actions/github-script@v6
              with:
                  script: |
                      const prNumber = context.payload.pull_request.number;
                      const prAuthor = context.payload.pull_request.user.login;
                      
                      const allReviewers = ['NAKTA-Y', 'MINU234', 'Enble', 'woghrk12', 'PSW99'];
                      
                      const availableReviewers = allReviewers.filter(r => r !== prAuthor);
                      
                      // Fisher-Yates shuffle
                      for (let i = availableReviewers.length - 1; i > 0; i--) {
                          const j = Math.floor(Math.random() * (i + 1));
                          [availableReviewers[i], availableReviewers[j]] = [availableReviewers[j], availableReviewers[i]];
                      }
                      
                      const selectedReviewers = availableReviewers.slice(0, 3);
                      
                      if (selectedReviewers.length > 0) {
                          try {
                              await github.rest.pulls.requestReviewers({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  pull_number: prNumber,
                                  reviewers: selectedReviewers
                              });
                              console.log(`Added reviewers: ${selectedReviewers.join(', ')}`);
                          } catch (error) {
                              console.error('Failed to add reviewers:', error);
                          }
                      }

    auto-merge:
        if: github.event_name == 'pull_request_review' && github.event.review.state == 'approved'
        runs-on: ubuntu-latest
        permissions:
            pull-requests: write
            contents: write
        steps:
            - name: Merge and Close PR if Approved
              uses: actions/github-script@v6
              with:
                  script: |
                      const prNumber = context.payload.pull_request.number || context.payload.review.pull_request_number;
                      try {
                        const pr = await github.rest.pulls.get({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          pull_number: prNumber
                        });
                        
                        if (pr.data.merged) {
                          console.log('PR이 이미 머지되었습니다.');
                          return;
                        }

                        if (!pr.data.mergeable) {
                          console.log('PR에 충돌이 있습니다.');
                          core.setFailed('PR에 충돌이 있어 자동 머지를 진행할 수 없습니다.');
                          return;
                        }

                        // CI 체크 상태 확인
                        const checks = await github.rest.checks.listForRef({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          ref: pr.data.head.sha
                        });

                        // GitHub Actions는 check_runs로 표시됨
                        const checkRuns = checks.data.check_runs;

                        // 디버깅: 모든 체크 상태 출력
                        console.log(`총 ${checkRuns.length}개의 체크 발견:`);
                        checkRuns.forEach(check => {
                          console.log(`  - ${check.name}: status=${check.status}, conclusion=${check.conclusion}`);
                        });

                        // 이 워크플로우 자체를 제외한 체크만 확인
                        const relevantChecks = checkRuns.filter(check =>
                          check.name !== 'Merge and Close PR if Approved'
                        );

                        console.log(`자기 자신 제외 후: ${relevantChecks.length}개의 체크`);

                        // 체크가 하나도 없으면 통과로 간주
                        if (relevantChecks.length === 0) {
                          console.log('CI 체크가 설정되지 않았습니다. 머지를 진행합니다.');
                        } else {
                          // 실패한 체크가 있는지 확인 (진행 중인 것은 무시)
                          const failedChecks = relevantChecks.filter(check =>
                            check.status === 'completed' && check.conclusion !== 'success'
                          );

                          const inProgressChecks = relevantChecks.filter(check =>
                            check.status !== 'completed'
                          );

                          if (failedChecks.length > 0) {
                            console.log(`CI 체크 실패: ${failedChecks.map(c => c.name).join(', ')}`);
                            core.setFailed('CI 체크를 통과해야 자동 머지가 가능합니다.');
                            return;
                          }

                          if (inProgressChecks.length > 0) {
                            console.log(`CI 체크 진행 중: ${inProgressChecks.map(c => c.name).join(', ')}`);
                            console.log('CI 완료 후 다시 시도됩니다.');
                            return; // 에러 아님, 나중에 재시도
                          }

                          console.log('모든 CI 체크 통과!');
                        }

                        const reviews = await github.rest.pulls.listReviews({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          pull_number: prNumber
                        });

                        const latestReviews = new Map();
                        reviews.data.forEach(review => {
                          latestReviews.set(review.user.login, review.state);
                        });

                        const hasRejection = Array.from(latestReviews.values()).includes('CHANGES_REQUESTED');
                        const approvalCount = Array.from(latestReviews.values()).filter(state => state === 'APPROVED').length;

                        if (!hasRejection && approvalCount >= 2) {
                          console.log('PR 머지를 시도합니다...');
                          await github.rest.pulls.merge({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            pull_number: prNumber
                          });

                          const branchName = pr.data.head.ref;
                          if (branchName !== 'main' && branchName !== 'develop') {
                            await github.rest.git.deleteRef({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              ref: `heads/${branchName}`
                            });
                            console.log(`브랜치 삭제: ${branchName}`);
                          }
                        } else {
                          console.log(`머지 조건 미충족 - Approvals: ${approvalCount}/2, Rejection: ${hasRejection}`);
                        }
                      } catch (error) {
                        console.error('Error:', error);
                        core.setFailed(error.message);
                      }
